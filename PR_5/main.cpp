#include <iostream>
#include <vector>

using namespace std;

typedef struct graph {
	int E = 0, V = 0; // Количество ребер и вершин
	vector<vector<int>> g; // Связи в графе
};

typedef graph* Graph;

class GrApH {
public:
	Graph GRAPHInit(int V) { // Инициализация графа из V вершин
		Graph gr = new graph; // Создаем новый граф
		gr->V = V; // Записываем количество вершин
		vector<vector<int>> gt(V + 1); // Создаем список, который будет содержать связи графа
		int NeOr, Or; // Создаем переменные, которые отвечают за неориент. и ориент. вершины
		cout << "Количество неориентированных ребер = ";
		cin >> NeOr; // Записываем количество неориентированных ребер
		cout << "Количество ориентированных ребер = ";
		cin >> Or; // Записываем количество ориентированных ребер
		gr->E = Or + 2 * NeOr; // Сохраняем количество ребер
		for (int k = Or + 2 * NeOr; k > 0; k--) { // Заполнение связей в графе
			int v1, v2, distance; // Инициализируем 2 вершины и дистанцию между ними
			cin >> v1 >> v2 >> distance; // Считываем 2 вершины, соединенные ребром и дистанцию
			if (distance > gt[v1].size()) { // Если дистанция больше допустимой на текущем шаге
				gt[v1].resize(distance + 100); // Расширяем список, который отвечает за дистанции
			}
			auto iter = gt[v1].cbegin(); // Инициализируем итератор
			gt[v1].insert(iter + v2, distance); // Создаем связь между вершинами и записываем
			// дистанцию между ними
		}
		gr->g = gt; // Записываем созданный список связей в список связей графа
		return gr; // Возвращаем созданный граф
	}

	void printGraph(Graph Gr) { // Функция отображения графа
		cout << "\n---ОТОБРАЖЕНИЕ ГРАФА В ПАМЯТИ---\n\n";
		for (int i = 1; i != Gr->g.size(); i++) { // Пока основной список вершин не пройден
			for (int y = 0; y != Gr->g[i].size(); y++) { // Пока список подчиненных вершин не пройден
				if (Gr->g[i][y] != 0) cout << "Вершина " << i << " соединена с вершиной " << y << "\n";
				// Если у ребра есть вес, то вывести соединенные вершины
			}
		}
	}

	void expV(Graph Gr) { // Функция определения степени вершины
		int ver, k = 0; //  ver - нужная вершина, k - её степень
		cout << "Степень какой вершины нужно определить?\n";
		cin >> ver; // Ввод вершины, степень которой нужно определить
		if (ver > Gr->g.size()) { // Если введена несуществующая вершина
			cout << "Такой вершины нет в графе!\n"; // Сообщить об ошибке
			return; // Выйти из функции нахождения степени вершины
		}
		else { // Если вершина существует в графе
			for (int i = 1; i < Gr->g.size(); i++) { // Пока основной список вершин не пройден
				for (int y = 1; y < Gr->g[i].size(); y++) { // Пока подчиненные вершины не пройдены
					if ((i == ver || y == ver) && Gr->g[i][y] != 0) k++;
					// Если одна из вершин является той, что мы ищем произвоидим инкремент k
				}
			}
			cout << "Степень вершины " << ver << " равна " << k << "\n"; // Вывод результата
		}
	}

	void dijkstra(Graph Gr) { // Вывод кратчайшего пути от одной вершины к другой с помощью метода Дейкстры
		int v1, v2; // Создаем переменные, которые отвечают за вершины
		cout << "\nВведите вершину, от которой нужно построить путь\n";
		cin >> v1; // Получаем вершину, от которой будем строить путь
		cout << "\nВведите вершину, к которой нужно построить путь\n";
		cin >> v2; // Получаем вершину, к которой будем строить путь	
		bool visited[10000]; // Создаем список посещенных вершин
		int dist[10000], parents[100][100];
		if (v1 == v2) dist[v2] = 0;
		else {
			// dist - массив с дистанциями между вершинами
			// parents - двумерный массив предшествующих вершин в пути
			for (int i = 1; i < Gr->V + 1; i++) { // Запись дистанции каждого ребра
				dist[i] = Gr->g[v1][i]; // Записываем вес ребра в массив дистанций
				if (dist[i] == 0 && i != v1) { // Если дистанция 0 и это не вершина, от которой мы строим путь 
					dist[i] = INT_MAX; // Значение дистанции становится очень большим
				}
				visited[i] = false; // Помечаем вершину как непосещенную
			}
			dist[v1] = 0; // Назначение дистанции от изначальной вершине к самой себе = 0
			int k; // Создаем переменную, которая будет отвечать за минимальную дистанцию 
			for (int i = 1; i < Gr->V + 1; i++) { // Пока не посещены все вершины
				int min = INT_MAX; // Минимальный элемент - очень большой
				for (int j = 1; j < Gr->V + 1; j++) // Пока не посещены все подчиненные вершины текущей вершины
				{
					if (!visited[j] && dist[j] < min && dist[j] != 0)
					{ // Если мы ещё не посещали вершину, и дистанция между текущими вершинами меньше
						// чем текущее значение меньшей дистанции и дистанция между вершинами не 0
						min = dist[j]; // Минимальное значение - дистанция между текущими вершинами
						k = j; // Сохраняем индекс минимальной дистанции в массиве dist
					}
				}
				visited[k] = true; // Помечаем вершину как посещенную
				for (int j = 1; j != Gr->g[k].size() + 1; j++) { // Пока мы не прошли все вершины
					if (!visited[j] && Gr->g[k][j] != INT_MAX && dist[k] != INT_MAX && (dist[k] + Gr->g[k][j] < dist[j]) && Gr->g[k][j] != 0)
					{ // Если мы ещё не посещали вершину и дистанция между текущими вершинами не максимально большая
						// и новая дистанция будет меньше чем текущая дистанция между вершинами и расстояние между вершинами не 0
						dist[j] = dist[k] + Gr->g[k][j]; // Назначаем новую минимальную дистанцию
						for (int h = 0; h < 100; h++) {
							if (parents[j][h] = 1) parents[j][h] = -1; // Заполняем столбец отвечающий за предков текущей вершины -1
						}
						parents[j][k] = 1; // В столбце предков вершины у текущей вершины помечаем предка, заполняя
						// столбец с индексом предка единицей
					}
				}
			}
		}
		cout << v1 << " -> " << v2 << " Дистанция = " << dist[v2] << "\n"; // Вывод минимальной дистанции между вершинами
		int reparents[10000], j = 0, v2_new = v2;
		cout << "Путь: " << v1 << " -> "; // Выводим на экран вершину, от которой был построен путь
		for (int i = 0; i < Gr->V; i++) { // Проходимся во всем подчиненным вершинам текущей
			if (parents[v2_new][i] == 1) { // Если найден предок у вершины, которая сейчас является конечной в пути
				reparents[j] = i; // Тогда заносим её в массив родителей
				j++; // Инкремент итератора списка родителей
				v2_new = i; // Найденный родитель вешины становится новой текущей вершиной
				i = 0; // Начинаем цикл с самого начала
			}
		}
		for (int i = 10000; i >= 0; i--) { // Проходимся по массиву родителей конечной вершины
			if (reparents[i] > 0) cout << reparents[i] << " -> "; // Если ячейка массива больше нуля, то выводим вершину
		}
		cout << v2 << "\n"; // Выводим на экран конечную вершину пути
	}
};
int main() {
	setlocale(LC_ALL, "Russian");
	Graph Gr = new graph;
	int n;
	cout << "Количество вершин = ";
	cin >> n;
	GrApH GrapH;
	Gr = GrapH.GRAPHInit(n);
	while (true) {
		int t;
		cout << "\n-----МЕНЮ-----\n";
		cout << "1 - Вывод графа на экран\n";
		cout << "2 - Опеределить степень вершины\n";
		cout << "3 - Вывод кратчайшего пути от одной вершины к другой с помощью метода Дейкстры\n";
		cout << "0 - Выход из программы\n";
		cin >> t;
		if (t == 0) break;
		else if (t == 1) {
			GrapH.printGraph(Gr);
		}
		else if (t == 2) {
			GrapH.expV(Gr);
		}
		else if (t == 3) {
			GrapH.dijkstra(Gr);
		}
	}
}
